def Shape as (Float l, Float u, PolyExp L, PolyExp U){[(curr[l]<=curr),(curr[u]>=curr),(curr[L]<=curr),(curr[U]>=curr)]};


func simplify_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[l]) : (coeff * n[u]);
func simplify_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[u]) : (coeff * n[l]);

func replace_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[L]) : (coeff * n[U]);
func replace_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[U]) : (coeff * n[L]);

func priority(Neuron n) = n[layer];
func priority2(Neuron n, Float c) = -n[layer];
func stop(Neuron n) = false;
func stop_traverse(Neuron n, Float c) = false;

func backsubs_lower(PolyExp e, Neuron n) = (e.traverse(backward, priority2, stop_traverse, replace_lower){e <= n}).map(simplify_lower);
func backsubs_upper(PolyExp e, Neuron n) = (e.traverse(backward, priority2, stop_traverse, replace_upper){e >= n}).map(simplify_upper);

func f(Neuron n1, Neuron n2) = n1[l] >= n2[u];

func slope(Float x1, Float x2) = ((x1 * (x1 + 3))-(x2 * (x2 + 3))) / (6 * (x1-x2));
func intercept(Float x1, Float x2) = x1 * ((x1 + 3) / 6) - (slope(x1, x2) * x1);

func f1(Float x) = x < 3 ? x * ((x + 3) / 6) : x;
func f2(Float x) = x * ((x + 3) / 6);
func f3(Neuron n) = max(f2(n[l]), f2(n[u]));

func compute_l(Neuron n1, Neuron n2) = min([n1[l]*n2[l], n1[l]*n2[u], n1[u]*n2[l], n1[u]*n2[u]]);
func compute_u(Neuron n1, Neuron n2) = max([n1[l]*n2[l], n1[l]*n2[u], n1[u]*n2[l], n1[u]*n2[u]]);


func elu(Float x) = (x >= 0) ? x : (sigma(x)/(1-sigma(x))- 1);


func slope_elu(Float l, Float u) = (elu(u) - elu(l)) / (u - l);

func intercept_elu(Float l, Float u) = elu(l) - slope_elu(l, u) * l;


transformer deeppoly{
    Affine -> (backsubs_lower(prev.dot(curr[weight]) + curr[bias], curr), backsubs_upper(prev.dot(curr[weight]) + curr[bias], curr), prev.dot(curr[weight]) + curr[bias], prev.dot(curr[weight]) + curr[bias]);


    Relu -> ((prev[l]) >= 0) ? ((prev[l]), (prev[u]), (prev), (prev)) : (((prev[u]) <= 0) ? (0, 0, 0, 0) : (0, (prev[u]), 0, (((prev[u]) / ((prev[u]) - (prev[l]))) * (prev)) - (((prev[u]) * (prev[l])) / ((prev[u]) - (prev[l]))) ));

    Abs -> (prev[l] >= 0) ? (prev[l], prev[u], prev, prev) : ((prev[u] <= 0) ? (0 - prev[u], 0 - prev[l], 0 - prev, 0 - prev) : (0, max(prev[u], 0 - prev[l]), 0, (prev * ((prev[u] + prev[l]) / (prev[u] - prev[l]))) - (((2 * prev[u]) * prev[l]) / (prev[u] - prev[l]))));


    HardSigmoid -> ((prev[u]) <= -3) ? (0, 0, 0, 0)
        : ((prev[l]) >= 3) ? (1, 1, 1, 1)
        : ((prev[u]) <= 3) ? (
            ((prev[l]) >= -3) ? (((prev[l] + 3) / 6), ((prev[u] + 3) / 6), ((prev + 3) / 6), ((prev + 3) / 6))
            : (0, ((prev[u] + 3) / 6), ((prev + 3) / 6), ((((prev[u] + 3) / 6) / (prev[u] - prev[l])) * (prev)) - ((((prev[u] + 3) / 6) / (prev[u] - prev[l])) * (prev[l])))
        )
        : ((prev[l]) >= -3) ? ((((prev[l] + 3) / 6), 1, (((1 - ((prev[l] + 3) / 6)) / (prev[u] - prev[l])) * (prev)) + (((prev[l] + 3) / 6) - (((1 - ((prev[l] + 3) / 6)) / (prev[u] - prev[l])) * (prev[l]))), ((prev + 3) / 6)))
        : (0, 1, 0, 1);


    HardSwish -> ((prev[u]) <= -3) ? (0, 0, 0, 0)
    : (((prev[l]) >= 3) ? ((prev[l]), (prev[u]), (prev), (prev))
    : (((prev[l]) >= -3) ? (((prev[u]) <= 3) ? (
        (0 - max(0 - f2(prev[l]), max(0 - f2(prev[u]), 0.375))),
        (f3(prev)),
        (0 - max(0 - f2(prev[l]), max(0 - f2(prev[u]), 0.375))),
        ((slope(prev[l], prev[u]) * prev) + intercept(prev[l], prev[u]))
    ) : (
        (0 - max(0 - ((prev[l] <= -3) ? 0 : ((prev[l] < 3) ? f2(prev[l]) : prev[l])) , max(0 - ((prev[u] <= -3) ? 0 : ((prev[u] < 3) ? f2(prev[u]) : prev[u])) , 0.375))),
        (max(((prev[l] <= -3) ? 0 : ((prev[l] < 3) ? f2(prev[l]) : prev[l])), max(((prev[u] <= -3) ? 0 : ((prev[u] < 3) ? f2(prev[u]) : prev[u])), 0))),
        (0 - max(0 - ((prev[l] <= -3) ? 0 : ((prev[l] < 3) ? f2(prev[l]) : prev[l])) , max(0 - ((prev[u] <= -3) ? 0 : ((prev[u] < 3) ? f2(prev[u]) : prev[u])) , 0.375))),
        (max(((prev[l] <= -3) ? 0 : ((prev[l] < 3) ? f2(prev[l]) : prev[l])), max(((prev[u] <= -3) ? 0 : ((prev[u] < 3) ? f2(prev[u]) : prev[u])), 0)))
    )) : (
        (0 - max(0 - ((prev[l] <= -3) ? 0 : ((prev[l] < 3) ? f2(prev[l]) : prev[l])) , max(0 - ((prev[u] <= -3) ? 0 : ((prev[u] < 3) ? f2(prev[u]) : prev[u])) , 0.375))),
        (max(((prev[l] <= -3) ? 0 : ((prev[l] < 3) ? f2(prev[l]) : prev[l])), max(((prev[u] <= -3) ? 0 : ((prev[u] < 3) ? f2(prev[u]) : prev[u])), 0))),
        (0 - max(0 - ((prev[l] <= -3) ? 0 : ((prev[l] < 3) ? f2(prev[l]) : prev[l])) , max(0 - ((prev[u] <= -3) ? 0 : ((prev[u] < 3) ? f2(prev[u]) : prev[u])) , 0.375))),
        (max(((prev[l] <= -3) ? 0 : ((prev[l] < 3) ? f2(prev[l]) : prev[l])), max(((prev[u] <= -3) ? 0 : ((prev[u] < 3) ? f2(prev[u]) : prev[u])), 0)))
    )));



    Sigmoid -> ((prev[u]) <= 0) ? (0, 0.5, (0.25 * (prev)) + 0.5, 0.5)
: (((prev[l]) >= 0) ? (0.5, 1, 0.5, (0.25 * (prev)) + 0.5)
: (0, 1, 0, 1));



        Elu -> (
        (prev[u] <= 0) ?
            (
              -1, elu(prev[u]),
            -1,  slope_elu(prev[l], prev[u]) * prev + intercept_elu(prev[l], prev[u])
            )


        : ( (prev[l] >= 0) ?
            (
              prev[l], prev[u],
              prev,   prev
            )

          :
            (
              -1,        prev[u],
               prev,     slope_elu(prev[l], prev[u]) * prev + intercept_elu(prev[l], prev[u])
            )
          )
    );

}

flow(forward, priority, stop, deeppoly);
