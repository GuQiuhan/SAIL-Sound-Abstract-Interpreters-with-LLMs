def Shape as (Float l, Float u, PolyExp L, PolyExp U){[(curr[l]<=curr),(curr[u]>=curr),(curr[L]<=curr),(curr[U]>=curr)]};


func simplify_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[l]) : (coeff * n[u]);
func simplify_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[u]) : (coeff * n[l]);

func replace_lower(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[L]) : (coeff * n[U]);
func replace_upper(Neuron n, Float coeff) = (coeff >= 0) ? (coeff * n[U]) : (coeff * n[L]);

func priority(Neuron n) = n[layer];
func priority2(Neuron n) = -n[layer];

func stop(Int x, Neuron n, Float coeff) = true;

func backsubs_lower(PolyExp e, Neuron n, Int x) = (e.traverse(backward, priority2, stop(x), replace_lower){e <= n}).map(simplify_lower);
func backsubs_upper(PolyExp e, Neuron n, Int x) = (e.traverse(backward, priority2, stop(x), replace_upper){e >= n}).map(simplify_upper);

func f(Neuron n1, Neuron n2) = n1[l] >= n2[u];

func slope(Float x1, Float x2) = ((x1 * (x1 + 3))-(x2 * (x2 + 3))) / (6 * (x1-x2));
func intercept(Float x1, Float x2) = x1 * ((x1 + 3) / 6) - (slope(x1, x2) * x1);

func f1(Float x) = x < 3 ? x * ((x + 3) / 6) : x;
func f2(Float x) = x * ((x + 3) / 6);
func f3(Neuron n) = max(f2(n[l]), f2(n[u]));

func compute_l(Neuron n1, Neuron n2) = min([n1[l]*n2[l], n1[l]*n2[u], n1[u]*n2[l], n1[u]*n2[u]]);
func compute_u(Neuron n1, Neuron n2) = max([n1[l]*n2[l], n1[l]*n2[u], n1[u]*n2[l], n1[u]*n2[u]]);

transformer deeppoly{
    Abs -> (prev[l] >= 0) ? (prev[l], prev[u], prev, prev) : ((prev[u] <= 0) ? (0 - prev[u], 0 - prev[l], 0 - prev, 0 - prev) : (0, max(prev[u], 0 - prev[l]), 0, (prev * ((prev[u] + prev[l]) / (prev[u] - prev[l]))) - (((2 * prev[u]) * prev[l]) / (prev[u] - prev[l]))));
    Affine -> (backsubs_lower(prev.dot(curr[weight]) + curr[bias], curr, curr[layer]), backsubs_upper(prev.dot(curr[weight]) + curr[bias], curr, curr[layer]), prev.dot(curr[weight]) + curr[bias], prev.dot(curr[weight]) + curr[bias]);

    Avgpool -> (backsubs_lower(avg(prev), curr, curr[layer]),backsubs_upper(avg(prev), curr, curr[layer]), avg(prev), avg(prev));


    HardSigmoid -> ((prev[u]) <= (-3)) ? (0, 0, 0, 0) : (((prev[l]) >= 3) ? (1, 1, 1, 1) : (((prev[l]) >= (-3)) ? (((prev[u]) <= 3) ? (((prev[l] / 6) + 0.5), ((prev[u] / 6) + 0.5), ((prev / 6) + 0.5), ((prev / 6) + 0.5)) : (((prev[l] / 6) + 0.5), (1), ((((0.5 - (prev[l] / 6)) / ((prev[u]) - (prev[l]))) * (prev)) + (((prev[l] / 6) + 0.5) - (((0.5 - (prev[l] / 6)) / ((prev[u]) - (prev[l]))) * (prev[l])))), (1))) : (((prev[u]) <= 3) ? ((0), ((prev[u] / 6) + 0.5), (0), (((((prev[u] / 6) + 0.5) / ((prev[u]) - (prev[l]))) * (prev)) - ((((prev[u] / 6) + 0.5) / ((prev[u]) - (prev[l]))) * (prev[l])))) : ((0), (1), (0), (1)))));

    HardSwish ->
        (prev[l] >= 3) ?
            (prev[l], prev[u], prev, prev)
        : (prev[u] <= -3) ?
            (0, 0, 0, 0)
        :
            (
                f1(prev[l]),
                f3(prev),
                slope(prev[l], prev[u]) * prev + intercept(prev[l], prev[u]),
                f3(prev)
            );

    HardTanh -> ((prev[u]) <= (-1)) ? ((-1), (-1), (-1), (-1)) : (((prev[l]) >= 1) ? (1, 1, 1, 1) : (((prev[u]) <= 1) ? (((prev[l]) < (-1)) ? ((-1), (prev[u]), (prev), (((((prev[u]) + 1) / ((prev[u]) - (prev[l]))) * (prev)) + ((-1) - ((((prev[u]) + 1) / ((prev[u]) - (prev[l]))) * (prev[l]))))) : ((prev[l]), (prev[u]), (prev), (prev))) : (((prev[l]) >= (-1)) ? ((prev[l]), (1), ((((1 - (prev[l])) / ((prev[u]) - (prev[l]))) * (prev)) + (((prev[l]) * ((prev[u]) - 1)) / ((prev[u]) - (prev[l])))), (1)) : ((-1), (1), (-1), (1)))) );

    Maxpool -> (max(prev[l]), max(prev[u]), max(prev[l]), max(prev[u]));

    Minpool -> (min(prev[l]), min(prev[u]), min(prev[l]), min(prev[u]));

    Neuron_add -> (backsubs_lower(prev_0 + prev_1, curr, curr[layer]), backsubs_upper(prev_0 + prev_1, curr, curr[layer]), prev_0 + prev_1, prev_0 + prev_1);

    Neuron_max -> (prev_0[l] >= prev_1[u]) ? (prev_0[l], prev_0[u], prev_0, prev_0) : ((prev_1[l] >= prev_0[u]) ? (prev_1[l], prev_1[u], prev_1, prev_1) : (max(prev_0[l], prev_1[l]), max(prev_0[u], prev_1[u]), (prev_0[l] >= prev_1[l]) ? prev_0 : prev_1, max(prev_0[u], prev_1[u])));

    Neuron_min -> ((prev_0[u]) <= (prev_1[l])) ? ((prev_0[l]), (prev_0[u]), (prev_0), (prev_0)) : (((prev_1[u]) <= (prev_0[l])) ? ((prev_1[l]), (prev_1[u]), (prev_1), (prev_1)) : ((0 - max(0 - (prev_0[l]), 0 - (prev_1[l]))), (0 - max(0 - (prev_0[u]), 0 - (prev_1[u]))), (0 - max(0 - (prev_0[l]), 0 - (prev_1[l]))), (((prev_0) + (prev_1)) * 0.5)));

    Neuron_mult -> (min(min(prev_0[l] * prev_1[l], prev_0[l] * prev_1[u]), min(prev_0[u] * prev_1[l], prev_0[u] * prev_1[u])), max(max(prev_0[l] * prev_1[l], prev_0[l] * prev_1[u]), max(prev_0[u] * prev_1[l], prev_0[u] * prev_1[u])), (prev_1[l] * prev_0) + (prev_0[l] * prev_1) - (prev_0[l] * prev_1[l]), (prev_1[u] * prev_0) + (prev_0[l] * prev_1) - (prev_0[l] * prev_1[u]));

    Relu -> ((prev[l]) >= 0) ? ((prev[l]), (prev[u]), (prev), (prev)) : (((prev[u]) <= 0) ? (0, 0, 0, 0) : (0, (prev[u]), 0, (((prev[u]) / ((prev[u]) - (prev[l]))) * (prev)) - (((prev[u]) * (prev[l])) / ((prev[u]) - (prev[l]))) ));

    Relu6 -> ((prev[u]) <= 0) ? (0, 0, 0, 0) : (((prev[l]) >= 6) ? (6, 6, 6, 6) : (((prev[l]) >= 0) ? (((prev[u]) <= 6) ? ((prev[l]), (prev[u]), (prev), (prev)) : ((prev[l]), 6, ((((6 - (prev[l])) / ((prev[u]) - (prev[l]))) * (prev)) + (((prev[l]) * ((prev[u]) - 6)) / ((prev[u]) - (prev[l])))), 6)) : (((prev[u]) <= 6) ? (0, (prev[u]), 0, (((prev[u]) / ((prev[u]) - (prev[l]))) * (prev)) - (((prev[u]) * (prev[l])) / ((prev[u]) - (prev[l])))) : (0, 6, 0, 6))));

}

flow(forward, priority, true, deeppoly);
