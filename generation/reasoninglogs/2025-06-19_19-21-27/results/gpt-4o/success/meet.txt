The
`meet` operator (sometimes called "and" or "intersection") in the context of interval/polyhedral neural network analysis usually means to compute an
over-approximation of the intersection of two abstract elements. In DeepPoly, with two input neurons/abstract elements prev_0 and prev_1, the result is another
neuron whose bounds and polynomials soundly enclose the intersection of their concretizations.

**For intervals:**

- The lower bound is the maximum of the
lower bounds.
- The upper bound is the minimum of the upper bounds.

**For symbolic bounds:**
- The lower symbolic bound must be an over-approximation of the
maximum of the two symbolic lower bounds.
- The upper symbolic bound must be an under-approximation of the minimum of the two symbolic upper bounds.

However,
in DeepPoly, the symbolic bounds are chosen to soundly bound the intersection. The tightest sound (but still cheap) choice is:\n- Lower symbolic: maximum of the
two lower symbolic bounds

- Upper symbolic: minimum of the two upper symbolic bounds

But since DeepPoly\'s framework is constrained to one linear inequality
per neuron and is not closed under intersection, we have to over-approximate: we take the more relaxed lower bound and the tighter upper bound.\n- Lower symbolic:
maximum of two symbolic lower bounds at each concrete point, but still chosen from one or the other
- Upper symbolic: minimum of two symbolic upper bounds at
each concrete point, but still chosen from one or the other

**Case Analysis:**
For each component (neuron), the computation is:
- Output lower bound:
max(prev_0[l], prev_1[l])
- Output upper bound: min(prev_0[u], prev_1[u])
- Output lower symbolic: prev_0[L] if prev_0[l] ≥ prev_1[l], else prev_1[L]
- Output
upper symbolic: prev_0[U] if prev_0[u] ≤ prev_1[u], else prev_1[U]

This ensures that:
- The new lower bound is the highest of the lower bounds (so any value
in the output is at least both lower bounds)
- The symbolic lower bound comes from whichever lower bound is higher (since the lower bounding plane must be at
least as large as either input\'s lower bound)
- Similar principle for the upper bound.

**Summary for Transformer, per neuron:**
- If prev_0[l] ≥ prev_1[l]
and prev_0[u] ≤ prev_1[u] ⇒ prev_0 contains prev_1, pick prev_1\'s bounds
- If prev_1[l] ≥ prev_0[l] and prev_1[u] ≤ prev_0[u] ⇒ prev_1 contains prev_0, pick
prev_0\'s bounds
- Otherwise, for each bound, pick the tightest from the two:
    - Lower: max(prev_0[l], prev_1[l]), symbolic bound from the maximizing input

- Upper: min(prev_0[u], prev_1[u]), symbolic bound from the minimizing input

Ready to write DSL.


def Shape as (Float l, Float u, PolyExp L, PolyExp U){[(curr[l]<=curr),(curr[u]>=curr),(curr[L]<=curr),(curr[U]>=curr)]};

transformer deeppoly{
    Meet -> ((prev_0[l] >= prev_1[l]) && (prev_0[u] <= prev_1[u])) ? (prev_0[l], prev_0[u], prev_0[L], prev_0[U])
    : ((prev_1[l] >= prev_0[l]) && (prev_1[u] <= prev_0[u])) ? (prev_1[l], prev_1[u], prev_1[L], prev_1[U])
    : ( ( (prev_0[l] >= prev_1[l]) ? prev_0[l] : prev_1[l] ),
        ( (prev_0[u] <= prev_1[u]) ? prev_0[u] : prev_1[u] ),
        ( (prev_0[l] >= prev_1[l]) ? prev_0[L] : prev_1[L] ),
        ( (prev_0[u] <= prev_1[u]) ? prev_0[U] : prev_1[U] )
      );
}
