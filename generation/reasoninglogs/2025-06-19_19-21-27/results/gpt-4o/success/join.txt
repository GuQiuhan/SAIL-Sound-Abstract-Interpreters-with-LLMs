The 
`join` operator (in DeepPoly and similar domains) refers to the pointwise or elementwise joining of two abstract elements, elementwise forming the smallest 
interval/polyhedron containing both elements (typically after a branch, such as after an `if` statement). In DeepPoly, this means forming the least upper bound 
over the interval and poly constraints.

Let the two inputs to `join` be `prev_0` and `prev_1`, with respective bounds:
- prev_0: [l₀, u₀], [L₀, U₀]
- prev_1:
[l₁, u₁], [L₁, U₁]

1. Concrete bounds:
   - Lower bound: min(l₀, l₁)
      - Upper bound: max(u₀, u₁)
      
2. Symbolic (poly) bounds:
   - Lower poly bound: 
min(L₀, L₁)
   - Upper poly bound: max(U₀, U₁)
   
In summary, for each output neuron, the join operation takes the minimum of the lower bounds and the maximum of
the upper bounds, both for concrete and poly bounds.

The DSL transformer should combine these accordingly.


def Shape as (Float l, Float u, PolyExp L, PolyExp U){[(curr[l]<=curr),(curr[u]>=curr),(curr[L]<=curr),(curr[U]>=curr)]};

transformer deeppoly{
    Join -> (min(prev_0[l], prev_1[l]), max(prev_0[u], prev_1[u]), min(prev_0[L], prev_1[L]), max(prev_0[U], prev_1[U]));
}